package smpl.lang;

import java_cup.runtime.*;
import java.io.*;
import java.util.Vector;

parser code {:
	SMPLLexer lexer;
	InputStream in = null;

	public SMPLParser(String file) {
		try {
			in = new FileInputStream(file);
			lexer = new SMPLLexer(new InputStreamReader(in));
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}	    
	}

	public void report_error(String message, Object info) {
	    System.err.println(message + info);
	}

	public void syntax_error(Symbol cur_token) {
		System.err.print("Line " + lexer.getLine() +
				         " near char " + lexer.getChar() + ": ");
		report_error("Syntax error while reading: ", cur_token);
		System.err.println ("Last token read is " +
					        lexer.getText());
	}

:};

init with {:
    // Create a lexer that reads from specified input stream
    if (in == null) {
		in = System.in;
		lexer = new SMPLLexer( new InputStreamReader(in) );
	}
	setScanner( lexer );
:};

// special symbols
terminal            SEMI, COLON, SPREAD, LPAREN, RPAREN, LBRACE, RBRACE, LBRAK, RBRAK, MAP, COMMA;
terminal String		IDENTIFIER;
terminal String		STRING;
terminal Integer   	NUMBER;        // our scanner provides numbers as integers
terminal Boolean	TRUE, FALSE;

// display operators
terminal PRINT, READ;

// list operators
terminal NIL;

// operators: arithmetic
terminal PLUS, ASSIGNADD, INCREMENT, MINUS, ASSIGNSUB, DECREMENT, TIMES, ASSIGNTIMES, EXPONENT, DIVIDE, ASSIGNDIVIDE, RADICAL, MOD, ASSIGNMOD;

// operators: bitwise
terminal AMP, ASSIGNAMP, BAR, ASSIGNBAR, CARET, ASSIGNCARET, TILDE;

// operators: relational
terminal EQ, GT, LT, LTEQ, GTEQ, NOTEQ;

// operators: logical
terminal AND, OR, NOT;

// operators: assignment
terminal ASSIGN, IMPLY, QUERY, CASES, CONTINUE, BREAK;

/* Non terminals */
non terminal			program;
non terminal Vector		statement_list;
non terminal Vector		statement_block;
non terminal			statement;
non terminal String		variable;
non terminal Vector		intialize_list;
non terminal Vector		dictionary;
non terminal Vector		array;
non terminal Vector		case_list;
non terminal			case;
non terminal Vector		if_clause_list;
non terminal			if_clause;
non terminal Integer    expression_list;
non terminal Boolean	condition_list;
non terminal Boolean	condition;
non terminal Integer   	expression;      // used to store evaluated subexpressions
non terminal Vector 	parameter_list;
non terminal Vector		variable_list;
non terminal empty;

/* Precedences. Highest precedence is at the bottom. */
precedence nonassoc LPAREN, RPAREN, COLON, QUERY;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc GT, LT, EQ, LTEQ, GTEQ, NOTEQ;
precedence left AMP, BAR, CARET;
precedence left PLUS, MINUS;
precedence left INCREMENT, DECREMENT;
precedence left TIMES, DIVIDE, MOD;
precedence left EXPONENT;
precedence left RADICAL;
precedence left TILDE;

/* Grammar Rules */

program ::= statement_list:sl 						{: System.out.println(sl); :};

statement_block ::= LBRACE statement_list:l RBRACE	{: RESULT = l; :}
				;

statement_list ::= statement:stmt statement_list:sl {: sl.addElement(stmt); RESULT = sl ; :} 
				
				| empty 							{: RESULT = new Vector(); :}
				;

statement ::= expression_list:l SEMI							{: RESULT = l;	:}

			| IDENTIFIER:i ASSIGN expression_list:l SEMI		{: RESULT = "CMD " + i + " = " + l + "";	:}

			| IDENTIFIER:i ASSIGN LBRAK array:l RBRAK SEMI		{: RESULT = "ARRAY " + i + " = " + l; :}

			| IDENTIFIER:i ASSIGN LBRAK dictionary:l RBRAK SEMI		{: RESULT = "DICTIONARY " + i + " = " + l; :}

			| IDENTIFIER:i ASSIGN LPAREN variable_list:l RPAREN statement_block:sl {: RESULT = "CMD " + i + " = (" + l + ") {\n" + sl + "\n}"; :}

			| condition_list:l QUERY expression_list:e SEMI			{: RESULT = "CMD condition ? " + e; :}

			| condition_list:l QUERY expression_list:e1 COLON expression_list:e2 SEMI	{: RESULT = "CMD condition ? " + e1 + " : " + e2; :}

			| CASES LBRACE if_clause_list:l RBRACE	{: RESULT = "IF-ELSES " + l; :}

			| CASES LPAREN expression_list:e RPAREN LBRACE case_list:l RBRACE	{: RESULT = "CASE ( " + e + " ) " + l; :}

			| LPAREN intialize_list:il SEMI condition_list:cl SEMI expression_list:e RPAREN statement_block:sl {: RESULT = "LOOP (" + il + "; " + cl + "; " + e + ") {\n" + sl + "\n}"; :}

			| LBRAK array:l RBRAK SEMI		{: RESULT = "ARRAY = " + l; :}

			| LBRAK dictionary:l RBRAK SEMI		{: RESULT = "DICTIONARY = " + l; :}

			| PRINT STRING:s SEMI	{: RESULT = s; :}

			| IDENTIFIER:i READ	SEMI	{: RESULT = "READ INTO " + i; :}
			;

intialize_list ::= IDENTIFIER:i ASSIGN expression_list:e COMMA intialize_list:l {: l.addElement(i + " = " + e); RESULT = l; :}
			
			| IDENTIFIER:i ASSIGN expression_list:e {: Vector l = new Vector(); l.addElement(i + " = " + e); RESULT = l;:}
			;

parameter_list ::= expression_list:e COMMA parameter_list:l		{: l.addElement(e); RESULT = l; :}

			| expression_list:e							{: Vector l = new Vector(); l.addElement(e); RESULT = l;:}
			
			| empty										{: RESULT = new Vector(); 		:}
			;

variable_list ::= variable:v COMMA variable_list:l	{: l.addElement(v); RESULT = l; :}

			| variable:v							{: Vector l = new Vector(); l.addElement(v); RESULT = l;:}

			| empty									{: RESULT = new Vector(); :}
			;

variable ::= COLON IDENTIFIER:i			{: RESULT = i; :}
			;

dictionary ::= STRING:s MAP expression_list:e COMMA dictionary:l {: l.addElement(s + " => " + e); RESULT = l; :}

			| STRING:s MAP expression_list:e {: Vector l = new Vector(); l.addElement(s + " => " + e); RESULT = l; :}
			;

array ::= expression_list:e COMMA array:l		{: l.addElement(e); RESULT = l;:}

			| expression_list:n COLON IDENTIFIER:i IMPLY expression_list:e COMMA array:l {: l.addElement("EXPAND " + n + " " + i + " -> "); RESULT = l; :}

			| expression_list:e		{: Vector l = new Vector(); l.addElement(e); RESULT = l;:}

			| expression_list:n COLON IDENTIFIER:i IMPLY expression_list:e  {: Vector l = new Vector(); l.addElement("EXPAND " + n + " " + i + " -> "); RESULT = l; :}

			| empty									{: RESULT = new Vector(); :}
			;

expression_list ::= expression_list expression:e	{: RESULT = e;			:}

            | expression:e							{: RESULT = e;			:}
			;

expression ::= 	expression:e1 PLUS expression:e2	{: RESULT = e1 + e2;       	:}

			| expression:e INCREMENT			{: RESULT = e++;       	:}

            | expression:e1 MINUS expression:e2	{: RESULT = e1 - e2;       	:}

			| expression:e DECREMENT			{: RESULT = e--;       	:}

            | expression:e1 TIMES expression:e2	{: RESULT = e1 * e2;       	:}

			| expression:e1 EXPONENT expression:e2	{: RESULT = (int)Math.pow(e1, e2); :}

			| expression:e1 DIVIDE expression:e2	{: RESULT = e1 / e2;       	:}

			| RADICAL expression:e {: RESULT = (int)Math.sqrt(e); :}

			| expression:e1 MOD expression:e2		{: RESULT = e1 % e2;       	:}

			| expression:e1 AMP expression:e2		{: RESULT = e1 & e2;		:}

			| expression:e1 BAR expression:e2		{: RESULT = e1 | e2;		:}

			| expression:e1 CARET expression:e2		{: RESULT = e1 ^ e2;		:}

			| TILDE expression:e					{: RESULT = ~e;		:}

            | LPAREN MINUS expression:e RPAREN		{: RESULT = -e;				:}

            | LPAREN expression_list:e RPAREN			{: RESULT = e;           	:}

			| BAR IDENTIFIER:i BAR	{: RESULT = 45; // returns size of array or absolute of number :}

			| IDENTIFIER:i LPAREN parameter_list:l RPAREN		{: RESULT = 5; :}

			| IDENTIFIER:i LBRAK STRING RBRAK 		{: RESULT = 7; :}

			| IDENTIFIER:i LBRAK expression_list:n RBRAK 	{: RESULT = 1; :}

			| IDENTIFIER:i							{: RESULT = 2; // TBC .. I have a dilemma here. This clashes with a rule in statement but I need to to evaluate a variable in expressions		:}

            | NUMBER:n	      						{: RESULT = n;           	:}

			| NIL									{: RESULT = null;			:}
             ;

case_list ::= case:c case_list:l {: l.addElement(c); RESULT = l; :}

			| empty	{: RESULT = new Vector(); :}
			;

case ::= STRING:s COLON expression_list:e SEMI {: RESULT = "CASE " + s + ": " + e; :}
			;

if_clause_list ::= if_clause:c if_clause_list:l {: l.addElement(c); RESULT = l; :}

			| empty	{: RESULT = new Vector(); :}
			;

if_clause ::= condition_list:c COLON expression_list:e SEMI {: RESULT = "IF-ELSE " + c + ": " + e; :}
			;

condition_list ::= condition_list:c1 AND condition:c2	{: RESULT = (c1 && c2);	:}

				| condition_list:c1 OR condition:c2		{: RESULT = (c1 || c2);	:}

				| NOT condition:c						{: RESULT = (!c);		:}

				| condition:c							{: RESULT = c;			:}
				;

condition ::=  expression:e1 EQ expression:e2		{: RESULT = (e1.equals(e2));:}

            	| expression:e1 LT expression:e2	{: RESULT = (e1 < e2); 		:}

            	| expression:e1 GT expression:e2	{: RESULT = (e1 > e2); 		:}

				| expression:e1 LTEQ expression:e2 	{: RESULT = (e1 <= e2); 	:}

				| expression:e1 GTEQ expression:e2	{: RESULT = (e1 >= e2); 	:}

				| expression:e1 NOTEQ expression:e2	{: RESULT = (e1 != e2); 	:}

				| LPAREN condition:c RPAREN			{: RESULT = c;				:}

				| TRUE								{: RESULT = true;			:}

				| FALSE								{: RESULT = false;			:}
               ;

empty ::=;