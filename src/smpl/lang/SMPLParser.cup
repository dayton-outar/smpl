package smpl.lang;

import java_cup.runtime.*;
import java.io.*;
import java.util.Vector;
import java.util.Hashtable;
import smpl.sys.*;
import smpl.sys.expressions.*;
import smpl.sys.commands.*;
import smpl.sys.values.Cases;
import smpl.sys.values.Elses;

parser code {:
	SMPLLexer lexer;
	InputStream in = null;

	public SMPLParser(String file) {
		try {
			in = new FileInputStream(file);
			lexer = new SMPLLexer(new InputStreamReader(in));
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}	    
	}

	public void report_error(String message, Object info) {
	    System.err.println(message + info);
	}

	public void syntax_error(Symbol cur_token) {
		System.err.print("Line " + lexer.getLine() +
				         " near char " + lexer.getChar() + ": ");
		report_error("Syntax error while reading: ", cur_token);
		System.err.println ("Last token read is " +
					        lexer.getText());
	}

:};

init with {:
    // Create a lexer that reads from specified input stream
    if (in == null) {
		in = System.in;
		lexer = new SMPLLexer( new InputStreamReader(in) );
	}
	setScanner( lexer );
:};

// special symbols
terminal            SEMI, COLON, SPREAD, LPAREN, RPAREN, LBRACE, RBRACE, LBRAK, RBRAK, MAP, COMMA;
terminal String		IDENTIFIER;
terminal String		STRING;
terminal Long   	LONG;
terminal Double		DOUBLE;
terminal Boolean	TRUE, FALSE;

// display operators
terminal PRINT, READ;

// list operators
terminal NIL;

// operators: arithmetic
terminal PLUS, ASSIGNADD, INCREMENT, MINUS, ASSIGNSUB, DECREMENT, TIMES, ASSIGNTIMES, EXPONENT, DIVIDE, ASSIGNDIVIDE, RADICAL, MOD, ASSIGNMOD;

// operators: bitwise
terminal AMP, ASSIGNAMP, BAR, ASSIGNBAR, CARET, ASSIGNCARET, TILDE;

// operators: relational
terminal EQ, GT, LT, LTEQ, GTEQ, NOTEQ;

// operators: logical
terminal AND, OR, NOT;

// operators: assignment
terminal ASSIGN, IMPLY, QUERY, CASES, CONTINUE, BREAK;

/* Non terminals */
non terminal Program						program;
non terminal Vector<ICommand>				statement_list;
non terminal Vector<ICommand>				statement_block;
non terminal ICommand						statement;
non terminal Vector<ICommand>				intialize_list;
non terminal Hashtable<String,IExpression>	dictionary;
non terminal Vector<IExpression>			array;
non terminal Vector							case_list;
non terminal								case;
non terminal Vector<Elses>					if_clause_list;
non terminal Elses							if_clause;
non terminal IExpression					expression_sequence;
non terminal IExpression					condition_sequence;
non terminal IExpression					condition;
non terminal IExpression					expression;
non terminal Vector<IExpression> 			parameter_list;
non terminal String							variable;
non terminal Vector<String>					variable_list;
non terminal empty;

/* Precedences. Highest precedence is at the bottom. */
precedence nonassoc LPAREN, RPAREN, LBRAK, RBRAK, COLON, QUERY;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc GT, LT, EQ, LTEQ, GTEQ, NOTEQ;
precedence left AMP, BAR, CARET;
precedence left PLUS, MINUS;
precedence left INCREMENT, DECREMENT;
precedence left TIMES, DIVIDE, MOD;
precedence left EXPONENT;
precedence left RADICAL;
precedence left TILDE;

/* Grammar Rules */

program ::= statement_list:sl
			{: RESULT = new Program(sl); :};

statement_block ::= LBRACE statement_list:l RBRACE
			{: RESULT = l; :}
			;

statement_list ::= statement:stmt statement_list:sl
			{: 
				sl.addElement(stmt);
				RESULT = sl;
			:} 
				
			| empty
			{: RESULT = new Vector<ICommand>(); :}
			;

statement ::= expression_sequence:e SEMI
			{: RESULT = new ExpressionCommand(e);	:}

			| expression:e INCREMENT SEMI
			{: RESULT = new IncrementCommand(e); :}

			| expression:e DECREMENT SEMI
			{: RESULT = new DecrementCommand(e); :}

			| IDENTIFIER:i ASSIGN expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNADD expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNSUB expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNTIMES expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNDIVIDE expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNMOD expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNAMP expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNBAR expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGNCARET expression_sequence:e SEMI
			{: RESULT = new AssignmentExpressionCommand(i, e); :}

			| IDENTIFIER:i ASSIGN LPAREN variable_list:l RPAREN statement_block:sl
			{: RESULT = new AssignmentFunctionCommand(i, l, sl); :}

			| IDENTIFIER:i ASSIGN LPAREN SPREAD IDENTIFIER:p RPAREN statement_block:sl
			{: RESULT = new AssignmentSpreadFunctionCommand(i, p, sl); :}

			| CASES LBRACE if_clause_list:l RBRACE
			{: RESULT = new ElsesCommand(l); :}

			| CASES LPAREN expression_sequence:e RPAREN LBRACE case_list:l RBRACE
			{: RESULT = new CasesCommand(e, l); :}

			| LPAREN intialize_list:il SEMI condition_sequence:c SEMI expression_sequence:e RPAREN statement_block:sl
			{: RESULT = new LoopCommand(il, c, e, sl); :}

			| PRINT STRING:s SEMI
			{: RESULT = new PrintCommand(s); :}

			| IDENTIFIER:i READ	SEMI
			{: RESULT = new ReadCommand(i); :}
			;

intialize_list ::= IDENTIFIER:i ASSIGN expression_sequence:e COMMA intialize_list:l 
			{: 
				l.addElement(new AssignmentExpressionCommand(i, e)); 
				RESULT = l; 
			:}
			
			| IDENTIFIER:i ASSIGN expression_sequence:e 
			{: 
				Vector<ICommand> l = new Vector<ICommand>();
				l.addElement(new AssignmentExpressionCommand(i, e));
				RESULT = l;
			:}
			;

parameter_list ::= expression_sequence:e COMMA parameter_list:l
			{: l.addElement(e); RESULT = l; :}

			| expression_sequence:e
			{: 
				Vector<IExpression> l = new Vector<IExpression>();
				l.addElement(e);
				RESULT = l;
			:}
			
			| empty
			{: RESULT = new Vector<IExpression>(); :}
			;

variable_list ::= variable:v COMMA variable_list:l
			{: l.addElement(v); RESULT = l; :}

			| variable:v
			{:
				Vector<String> l = new Vector<String>();
				l.addElement(v);
				RESULT = l;
			:}

			| empty
			{: RESULT = new Vector<String>(); :}
			;

variable ::= COLON IDENTIFIER:i	
			{: RESULT = i; :}
			;

dictionary ::= STRING:s MAP expression_sequence:e COMMA dictionary:l
			{:
				l.put(s, e);
				RESULT = l;
			:}

			| STRING:s MAP expression_sequence:e 
			{:
				Hashtable<String,IExpression> l = new Hashtable<String,IExpression>();
				l.put(s, e);
				RESULT = l;
			:}
			;

array ::= expression_sequence:e COMMA array:l
			{:
				l.addElement(e);
				RESULT = l;
			:}

			| expression_sequence:n COLON IDENTIFIER:i IMPLY expression_sequence:e COMMA array:l 
			{: 
				l.addElement(new ArrayInitializationExpression(n, i, e)); 
				RESULT = l; 
			:}

			| expression_sequence:e	
			{: 
				Vector<IExpression> l = new Vector<IExpression>(); 
				l.addElement(e); 
				RESULT = l;
			:}

			| expression_sequence:n COLON IDENTIFIER:i IMPLY expression_sequence:e 
			{:
				Vector<IExpression> l = new Vector<IExpression>();
				l.addElement(new ArrayInitializationExpression(n, i, e));
				RESULT = l;
			:}

			| empty	
			{: RESULT = new Vector<IExpression>(); :}
			;

expression_sequence ::= expression_sequence expression:e
			{: RESULT = e; :}

            | expression:e
			{: RESULT = e; :}
			;

expression ::= 	expression:e1 PLUS expression:e2
			{: RESULT = new AdditionExpression(e1, e2); :}

            | expression:e1 MINUS expression:e2
			{: RESULT = new SubtractionExpression(e1, e2); :}

            | expression:e1 TIMES expression:e2
			{: RESULT = new MultiplicationExpression(e1, e2); :}

			| expression:e1 EXPONENT expression:e2
			{: RESULT = new ExponentExpression(e1, e2); :}

			| expression:e1 DIVIDE expression:e2
			{: RESULT = new DivisionExpression(e1, e2); :}

			| RADICAL expression:e
			{: RESULT = new SquareRootExpression(e); :}

			| expression:e1 MOD expression:e2
			{: RESULT = new ModulusExpression(e1, e2); :}

			| expression:e1 AMP expression:e2
			{: RESULT = new BitwiseAndExpression(e1, e2); :}

			| expression:e1 BAR expression:e2
			{: RESULT = new BitwiseOrExpression(e1, e2); :}

			| expression:e1 CARET expression:e2
			{: RESULT = new BitwiseXorExpression(e1, e2); :}
			
			| TILDE expression:e
			{: RESULT = new BitwiseInvertExpression(e); :}

            | LPAREN MINUS expression:e RPAREN
			{: RESULT = new InvertExpression(e); :}

            | LPAREN expression_sequence:e RPAREN
			{: RESULT = e; :}

			| LPAREN condition_sequence:c RPAREN QUERY expression_sequence:e1 COLON expression_sequence:e2
			{: RESULT = new QueryExpression(c, e1, e2); :}

			| BAR IDENTIFIER:i BAR
			{: RESULT = new LongExpression(Long.valueOf(45)); // returns size of array or absolute of number :}

			| IDENTIFIER:i LPAREN parameter_list:l RPAREN
			{: RESULT = new FunctionExpression(i, l); :}

			| IDENTIFIER:i LBRAK STRING:x RBRAK
			{: RESULT = new DictionaryIndexExpression(i, x); :}

			| IDENTIFIER:i LBRAK expression_sequence:e RBRAK
			{: RESULT = new ArrayIndexExpression(i, e); :}

			| IDENTIFIER:i
			{: RESULT = new VariableExpression(i); :}
			
			| LBRAK array:l RBRAK
			{: RESULT = new ArrayExpression(l); :}

			| LBRAK dictionary:l RBRAK
			{: RESULT = new DictionaryExpression(l); :}

            | LONG:n
			{: RESULT = new LongExpression(n); :}

			| DOUBLE:n
			{: RESULT = new DoubleExpression(n); :}

			| NIL
			{: RESULT = null; :}
             ;

case_list ::= case:c case_list:l
			{:
				l.addElement(c);
				RESULT = l;
			:}

			| empty
			{: RESULT = new Vector<Cases>(); :}
			;

case ::= STRING:s COLON expression_sequence:e SEMI
			{: RESULT = new Cases(s, e); :}
			;

if_clause_list ::= if_clause:c if_clause_list:l 
			{: 
				l.addElement(c);
				RESULT = l;
			:}

			| empty	
			{: RESULT = new Vector<Elses>(); :}
			;

if_clause ::= condition_sequence:c COLON expression_sequence:e SEMI 
			{: RESULT = new Elses(c, e); :}
			;

condition_sequence ::= condition_sequence:c1 AND condition:c2
			{: RESULT = new LogicalAndExpression(c1, c2); :}

			| condition_sequence:c1 OR condition:c2
			{: RESULT = new LogicalOrExpression(c1, c2); :}

			| NOT condition:c
			{: RESULT = new LogicalNotExpression(c); :}

			| condition:c
			{: RESULT = c; :}
			;

condition ::=  expression:e1 EQ expression:e2
			{: RESULT = new EqualsExpression(e1, e2); :}

			| expression:e1 LT expression:e2
			{: RESULT = new LesserThanExpression(e1, e2); :}

            | expression:e1 GT expression:e2
			{: RESULT = new GreaterThanExpression(e1, e2); :}

			| expression:e1 LTEQ expression:e2
			{: RESULT = new LesserThanOrEqualsExpression(e1, e2); :}

			| expression:e1 GTEQ expression:e2
			{: RESULT = new GreaterThanOrEqualsExpression(e1, e2); 	:}

			| expression:e1 NOTEQ expression:e2
			{: RESULT = new NotEqualsExpression(e1, e2); :}

			| LPAREN condition:c RPAREN
			{: RESULT = c;	:}

			| TRUE
			{: RESULT = new BooleanExpression(Boolean.valueOf(true)); :}

			| FALSE
			{: RESULT = new BooleanExpression(Boolean.valueOf(false));	:}
            ;

empty ::=;