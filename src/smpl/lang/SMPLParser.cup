package smpl.lang;

import java_cup.runtime.*;
import java.io.*;

parser code {:
	SMPLLexer lexer;
	InputStream in = null;

	public SMPLParser(String file) throws FileNotFoundException {
	    in = new FileInputStream(file);
		lexer = new SMPLLexer(new InputStreamReader(in));
	}

	public void report_error(String message, Object info) {
	    System.err.println(message + info);
	}

	public void syntax_error(Symbol cur_token) {
		System.err.print("Line " + lexer.getLine() +
				         " near char " + lexer.getChar() + ": ");
		report_error("Syntax error while reading: ", cur_token);
		System.err.println ("Last token read is " +
					        lexer.getText());
	}

:};

init with {:
    // Create a lexer that reads from specified input stream
    if (in == null) {
		in = System.in;
		lexer = new SMPLLexer( new InputStreamReader(in) );
	}
	setScanner( lexer );
:};

// special symbols
terminal            SEMI, LPAREN, RPAREN;
terminal String		IDENTIFIER;
terminal Integer   	INTEGER_LITERAL;        // our scanner provides numbers as integers

// operators: arithmetic
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;

// operators: bitwise
terminal AMP, BAR, TILDE;

// operators: relational
terminal EQ, GT, LT, LTEQ, GTEQ, NOTEQ;

// operators: logical
terminal AND, OR, NOT;

// operators: assignment
terminal ASSIGN;

/* Non terminals */
non terminal			statement;
non terminal            expression_list;
non terminal			condition_list;
non terminal Boolean	condition;
non terminal Integer   	expression;      // used to store evaluated subexpressions

/* Precedences. Highest precedence is at the bottom. */
precedence nonassoc OR;
precedence nonassoc AND;
precedence nonassoc NOT;
precedence nonassoc GT, LT, EQ, LTEQ, GTEQ, NOTEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence nonassoc TILDE;

/* Grammar rules */
statement ::= expression_list:l SEMI				{: System.out.println(l);:}

			| condition_list:l SEMI					{: System.out.println(l);:}
			;

expression_list ::= expression_list expression:e	{: RESULT = e;			:}

            | expression:e							{: RESULT = e;			:}
			;

expression ::= 	expression:e1 PLUS expression:e2	{: RESULT = e1 + e2;       	:}

             | expression:e1 MINUS expression:e2	{: RESULT = e1 - e2;       	:}

             | expression:e1 TIMES expression:e2	{: RESULT = e1 * e2;       	:}

			 | expression:e1 DIVIDE expression:e2	{: RESULT = e1 / e2;       	:}

			 | expression:e1 MOD expression:e2		{: RESULT = e1 % e2;       	:}

             | LPAREN MINUS expression:e RPAREN		{: RESULT = -e;				:}

             | LPAREN expression:e RPAREN			{: RESULT = e;           	:}

             | INTEGER_LITERAL:n	      			{: RESULT = n;           	:}
             ;

condition_list ::= condition_list AND condition:c	{: RESULT = c;			:}

				| condition:c1 AND condition:c2		{: RESULT = (c1 && c2);	:}

				| condition:c1 OR condition:c2		{: RESULT = (c1 || c2);	:}

				| LPAREN condition:c RPAREN			{: RESULT = c;			:}

				| NOT condition:c					{: RESULT = (!c);		:}

				| condition:c						{: RESULT = c;			:}
				;

condition ::=  expression:e1 GT expression:e2	{: RESULT = (e1 > e2); 		:}

            	| expression:e1 LT expression:e2	{: RESULT = (e1 < e2); 	:}

            	| expression:e1 EQ expression:e2	{: RESULT = (e1.equals(e2));	:}

				| expression:e1 LTEQ expression:e2 	{: RESULT = (e1 <= e2); 	:}

				| expression:e1 GTEQ expression:e2	{: RESULT = (e1 >= e2); 	:}

				| expression:e1 NOTEQ expression:e2	{: RESULT = (e1 != e2); 	:}
               ;